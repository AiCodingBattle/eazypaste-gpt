{"version":3,"file":"main.js","sources":["../node_modules/readdirp/esm/index.js","../node_modules/chokidar/esm/handler.js","../node_modules/chokidar/esm/index.js","../electron/main.ts"],"sourcesContent":["import { stat, lstat, readdir, realpath } from 'node:fs/promises';\nimport { Readable } from 'node:stream';\nimport { resolve as presolve, relative as prelative, join as pjoin, sep as psep } from 'node:path';\nexport const EntryTypes = {\n    FILE_TYPE: 'files',\n    DIR_TYPE: 'directories',\n    FILE_DIR_TYPE: 'files_directories',\n    EVERYTHING_TYPE: 'all',\n};\nconst defaultOptions = {\n    root: '.',\n    fileFilter: (_entryInfo) => true,\n    directoryFilter: (_entryInfo) => true,\n    type: EntryTypes.FILE_TYPE,\n    lstat: false,\n    depth: 2147483648,\n    alwaysStat: false,\n    highWaterMark: 4096,\n};\nObject.freeze(defaultOptions);\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst ALL_TYPES = [\n    EntryTypes.DIR_TYPE,\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n    EntryTypes.FILE_TYPE,\n];\nconst DIR_TYPES = new Set([\n    EntryTypes.DIR_TYPE,\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n]);\nconst FILE_TYPES = new Set([\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n    EntryTypes.FILE_TYPE,\n]);\nconst isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);\nconst wantBigintFsStats = process.platform === 'win32';\nconst emptyFn = (_entryInfo) => true;\nconst normalizeFilter = (filter) => {\n    if (filter === undefined)\n        return emptyFn;\n    if (typeof filter === 'function')\n        return filter;\n    if (typeof filter === 'string') {\n        const fl = filter.trim();\n        return (entry) => entry.basename === fl;\n    }\n    if (Array.isArray(filter)) {\n        const trItems = filter.map((item) => item.trim());\n        return (entry) => trItems.some((f) => entry.basename === f);\n    }\n    return emptyFn;\n};\n/** Readable readdir stream, emitting new files as they're being listed. */\nexport class ReaddirpStream extends Readable {\n    constructor(options = {}) {\n        super({\n            objectMode: true,\n            autoDestroy: true,\n            highWaterMark: options.highWaterMark,\n        });\n        const opts = { ...defaultOptions, ...options };\n        const { root, type } = opts;\n        this._fileFilter = normalizeFilter(opts.fileFilter);\n        this._directoryFilter = normalizeFilter(opts.directoryFilter);\n        const statMethod = opts.lstat ? lstat : stat;\n        // Use bigint stats if it's windows and stat() supports options (node 10+).\n        if (wantBigintFsStats) {\n            this._stat = (path) => statMethod(path, { bigint: true });\n        }\n        else {\n            this._stat = statMethod;\n        }\n        this._maxDepth = opts.depth ?? defaultOptions.depth;\n        this._wantsDir = type ? DIR_TYPES.has(type) : false;\n        this._wantsFile = type ? FILE_TYPES.has(type) : false;\n        this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;\n        this._root = presolve(root);\n        this._isDirent = !opts.alwaysStat;\n        this._statsProp = this._isDirent ? 'dirent' : 'stats';\n        this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n        // Launch stream with one parent, the root dir.\n        this.parents = [this._exploreDir(root, 1)];\n        this.reading = false;\n        this.parent = undefined;\n    }\n    async _read(batch) {\n        if (this.reading)\n            return;\n        this.reading = true;\n        try {\n            while (!this.destroyed && batch > 0) {\n                const par = this.parent;\n                const fil = par && par.files;\n                if (fil && fil.length > 0) {\n                    const { path, depth } = par;\n                    const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));\n                    const awaited = await Promise.all(slice);\n                    for (const entry of awaited) {\n                        if (!entry) {\n                            batch--;\n                            return;\n                        }\n                        if (this.destroyed)\n                            return;\n                        const entryType = await this._getEntryType(entry);\n                        if (entryType === 'directory' && this._directoryFilter(entry)) {\n                            if (depth <= this._maxDepth) {\n                                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n                            }\n                            if (this._wantsDir) {\n                                this.push(entry);\n                                batch--;\n                            }\n                        }\n                        else if ((entryType === 'file' || this._includeAsFile(entry)) &&\n                            this._fileFilter(entry)) {\n                            if (this._wantsFile) {\n                                this.push(entry);\n                                batch--;\n                            }\n                        }\n                    }\n                }\n                else {\n                    const parent = this.parents.pop();\n                    if (!parent) {\n                        this.push(null);\n                        break;\n                    }\n                    this.parent = await parent;\n                    if (this.destroyed)\n                        return;\n                }\n            }\n        }\n        catch (error) {\n            this.destroy(error);\n        }\n        finally {\n            this.reading = false;\n        }\n    }\n    async _exploreDir(path, depth) {\n        let files;\n        try {\n            files = await readdir(path, this._rdOptions);\n        }\n        catch (error) {\n            this._onError(error);\n        }\n        return { files, depth, path };\n    }\n    async _formatEntry(dirent, path) {\n        let entry;\n        const basename = this._isDirent ? dirent.name : dirent;\n        try {\n            const fullPath = presolve(pjoin(path, basename));\n            entry = { path: prelative(this._root, fullPath), fullPath, basename };\n            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n        }\n        catch (err) {\n            this._onError(err);\n            return;\n        }\n        return entry;\n    }\n    _onError(err) {\n        if (isNormalFlowError(err) && !this.destroyed) {\n            this.emit('warn', err);\n        }\n        else {\n            this.destroy(err);\n        }\n    }\n    async _getEntryType(entry) {\n        // entry may be undefined, because a warning or an error were emitted\n        // and the statsProp is undefined\n        if (!entry && this._statsProp in entry) {\n            return '';\n        }\n        const stats = entry[this._statsProp];\n        if (stats.isFile())\n            return 'file';\n        if (stats.isDirectory())\n            return 'directory';\n        if (stats && stats.isSymbolicLink()) {\n            const full = entry.fullPath;\n            try {\n                const entryRealPath = await realpath(full);\n                const entryRealPathStats = await lstat(entryRealPath);\n                if (entryRealPathStats.isFile()) {\n                    return 'file';\n                }\n                if (entryRealPathStats.isDirectory()) {\n                    const len = entryRealPath.length;\n                    if (full.startsWith(entryRealPath) && full.substr(len, 1) === psep) {\n                        const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n                        // @ts-ignore\n                        recursiveError.code = RECURSIVE_ERROR_CODE;\n                        return this._onError(recursiveError);\n                    }\n                    return 'directory';\n                }\n            }\n            catch (error) {\n                this._onError(error);\n                return '';\n            }\n        }\n    }\n    _includeAsFile(entry) {\n        const stats = entry && entry[this._statsProp];\n        return stats && this._wantsEverything && !stats.isDirectory();\n    }\n}\n/**\n * Streaming version: Reads all files and directories in given root recursively.\n * Consumes ~constant small amount of RAM.\n * @param root Root directory\n * @param options Options to specify root (start directory), filters and recursion depth\n */\nexport function readdirp(root, options = {}) {\n    // @ts-ignore\n    let type = options.entryType || options.type;\n    if (type === 'both')\n        type = EntryTypes.FILE_DIR_TYPE; // backwards-compatibility\n    if (type)\n        options.type = type;\n    if (!root) {\n        throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n    }\n    else if (typeof root !== 'string') {\n        throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n    }\n    else if (type && !ALL_TYPES.includes(type)) {\n        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n    }\n    options.root = root;\n    return new ReaddirpStream(options);\n}\n/**\n * Promise version: Reads all files and directories in given root recursively.\n * Compared to streaming version, will consume a lot of RAM e.g. when 1 million files are listed.\n * @returns array of paths and their entry infos\n */\nexport function readdirpPromise(root, options = {}) {\n    return new Promise((resolve, reject) => {\n        const files = [];\n        readdirp(root, options)\n            .on('data', (entry) => files.push(entry))\n            .on('end', () => resolve(files))\n            .on('error', (error) => reject(error));\n    });\n}\nexport default readdirp;\n","import { watchFile, unwatchFile, watch as fs_watch } from 'fs';\nimport { open, stat, lstat, realpath as fsrealpath } from 'fs/promises';\nimport * as sysPath from 'path';\nimport { type as osType } from 'os';\nexport const STR_DATA = 'data';\nexport const STR_END = 'end';\nexport const STR_CLOSE = 'close';\nexport const EMPTY_FN = () => { };\nexport const IDENTITY_FN = (val) => val;\nconst pl = process.platform;\nexport const isWindows = pl === 'win32';\nexport const isMacos = pl === 'darwin';\nexport const isLinux = pl === 'linux';\nexport const isFreeBSD = pl === 'freebsd';\nexport const isIBMi = osType() === 'OS400';\nexport const EVENTS = {\n    ALL: 'all',\n    READY: 'ready',\n    ADD: 'add',\n    CHANGE: 'change',\n    ADD_DIR: 'addDir',\n    UNLINK: 'unlink',\n    UNLINK_DIR: 'unlinkDir',\n    RAW: 'raw',\n    ERROR: 'error',\n};\nconst EV = EVENTS;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst statMethods = { lstat, stat };\nconst KEY_LISTENERS = 'listeners';\nconst KEY_ERR = 'errHandlers';\nconst KEY_RAW = 'rawEmitters';\nconst HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];\n// prettier-ignore\nconst binaryExtensions = new Set([\n    '3dm', '3ds', '3g2', '3gp', '7z', 'a', 'aac', 'adp', 'afdesign', 'afphoto', 'afpub', 'ai',\n    'aif', 'aiff', 'alz', 'ape', 'apk', 'appimage', 'ar', 'arj', 'asf', 'au', 'avi',\n    'bak', 'baml', 'bh', 'bin', 'bk', 'bmp', 'btif', 'bz2', 'bzip2',\n    'cab', 'caf', 'cgm', 'class', 'cmx', 'cpio', 'cr2', 'cur', 'dat', 'dcm', 'deb', 'dex', 'djvu',\n    'dll', 'dmg', 'dng', 'doc', 'docm', 'docx', 'dot', 'dotm', 'dra', 'DS_Store', 'dsk', 'dts',\n    'dtshd', 'dvb', 'dwg', 'dxf',\n    'ecelp4800', 'ecelp7470', 'ecelp9600', 'egg', 'eol', 'eot', 'epub', 'exe',\n    'f4v', 'fbs', 'fh', 'fla', 'flac', 'flatpak', 'fli', 'flv', 'fpx', 'fst', 'fvt',\n    'g3', 'gh', 'gif', 'graffle', 'gz', 'gzip',\n    'h261', 'h263', 'h264', 'icns', 'ico', 'ief', 'img', 'ipa', 'iso',\n    'jar', 'jpeg', 'jpg', 'jpgv', 'jpm', 'jxr', 'key', 'ktx',\n    'lha', 'lib', 'lvp', 'lz', 'lzh', 'lzma', 'lzo',\n    'm3u', 'm4a', 'm4v', 'mar', 'mdi', 'mht', 'mid', 'midi', 'mj2', 'mka', 'mkv', 'mmr', 'mng',\n    'mobi', 'mov', 'movie', 'mp3',\n    'mp4', 'mp4a', 'mpeg', 'mpg', 'mpga', 'mxu',\n    'nef', 'npx', 'numbers', 'nupkg',\n    'o', 'odp', 'ods', 'odt', 'oga', 'ogg', 'ogv', 'otf', 'ott',\n    'pages', 'pbm', 'pcx', 'pdb', 'pdf', 'pea', 'pgm', 'pic', 'png', 'pnm', 'pot', 'potm',\n    'potx', 'ppa', 'ppam',\n    'ppm', 'pps', 'ppsm', 'ppsx', 'ppt', 'pptm', 'pptx', 'psd', 'pya', 'pyc', 'pyo', 'pyv',\n    'qt',\n    'rar', 'ras', 'raw', 'resources', 'rgb', 'rip', 'rlc', 'rmf', 'rmvb', 'rpm', 'rtf', 'rz',\n    's3m', 's7z', 'scpt', 'sgi', 'shar', 'snap', 'sil', 'sketch', 'slk', 'smv', 'snk', 'so',\n    'stl', 'suo', 'sub', 'swf',\n    'tar', 'tbz', 'tbz2', 'tga', 'tgz', 'thmx', 'tif', 'tiff', 'tlz', 'ttc', 'ttf', 'txz',\n    'udf', 'uvh', 'uvi', 'uvm', 'uvp', 'uvs', 'uvu',\n    'viv', 'vob',\n    'war', 'wav', 'wax', 'wbmp', 'wdp', 'weba', 'webm', 'webp', 'whl', 'wim', 'wm', 'wma',\n    'wmv', 'wmx', 'woff', 'woff2', 'wrm', 'wvx',\n    'xbm', 'xif', 'xla', 'xlam', 'xls', 'xlsb', 'xlsm', 'xlsx', 'xlt', 'xltm', 'xltx', 'xm',\n    'xmind', 'xpi', 'xpm', 'xwd', 'xz',\n    'z', 'zip', 'zipx',\n]);\nconst isBinaryPath = (filePath) => binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n    if (val instanceof Set) {\n        val.forEach(fn);\n    }\n    else {\n        fn(val);\n    }\n};\nconst addAndConvert = (main, prop, item) => {\n    let container = main[prop];\n    if (!(container instanceof Set)) {\n        main[prop] = container = new Set([container]);\n    }\n    container.add(item);\n};\nconst clearItem = (cont) => (key) => {\n    const set = cont[key];\n    if (set instanceof Set) {\n        set.clear();\n    }\n    else {\n        delete cont[key];\n    }\n};\nconst delFromSet = (main, prop, item) => {\n    const container = main[prop];\n    if (container instanceof Set) {\n        container.delete(item);\n    }\n    else if (container === item) {\n        delete main[prop];\n    }\n};\nconst isEmptySet = (val) => (val instanceof Set ? val.size === 0 : !val);\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param path to be watched\n * @param options to be passed to fs_watch\n * @param listener main event handler\n * @param errHandler emits info about errors\n * @param emitRaw emits raw event data\n * @returns {NativeFsWatcher}\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n    const handleEvent = (rawEvent, evPath) => {\n        listener(path);\n        emitRaw(rawEvent, evPath, { watchedPath: path });\n        // emit based on events occurring for files from a directory's watcher in\n        // case the file's watcher misses it (and rely on throttling to de-dupe)\n        if (evPath && path !== evPath) {\n            fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n        }\n    };\n    try {\n        return fs_watch(path, {\n            persistent: options.persistent,\n        }, handleEvent);\n    }\n    catch (error) {\n        errHandler(error);\n        return undefined;\n    }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param fullPath absolute path bound to fs_watch instance\n */\nconst fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {\n    const cont = FsWatchInstances.get(fullPath);\n    if (!cont)\n        return;\n    foreach(cont[listenerType], (listener) => {\n        listener(val1, val2, val3);\n    });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param path\n * @param fullPath absolute path\n * @param options to be passed to fs_watch\n * @param handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n    const { listener, errHandler, rawEmitter } = handlers;\n    let cont = FsWatchInstances.get(fullPath);\n    let watcher;\n    if (!options.persistent) {\n        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n        if (!watcher)\n            return;\n        return watcher.close.bind(watcher);\n    }\n    if (cont) {\n        addAndConvert(cont, KEY_LISTENERS, listener);\n        addAndConvert(cont, KEY_ERR, errHandler);\n        addAndConvert(cont, KEY_RAW, rawEmitter);\n    }\n    else {\n        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n        fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n        if (!watcher)\n            return;\n        watcher.on(EV.ERROR, async (error) => {\n            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n            if (cont)\n                cont.watcherUnusable = true; // documented since Node 10.4.1\n            // Workaround for https://github.com/joyent/node/issues/4337\n            if (isWindows && error.code === 'EPERM') {\n                try {\n                    const fd = await open(path, 'r');\n                    await fd.close();\n                    broadcastErr(error);\n                }\n                catch (err) {\n                    // do nothing\n                }\n            }\n            else {\n                broadcastErr(error);\n            }\n        });\n        cont = {\n            listeners: listener,\n            errHandlers: errHandler,\n            rawEmitters: rawEmitter,\n            watcher,\n        };\n        FsWatchInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n    // removes this instance's listeners and closes the underlying fs_watch\n    // instance if there are no more listeners left\n    return () => {\n        delFromSet(cont, KEY_LISTENERS, listener);\n        delFromSet(cont, KEY_ERR, errHandler);\n        delFromSet(cont, KEY_RAW, rawEmitter);\n        if (isEmptySet(cont.listeners)) {\n            // Check to protect against issue gh-730.\n            // if (cont.watcherUnusable) {\n            cont.watcher.close();\n            // }\n            FsWatchInstances.delete(fullPath);\n            HANDLER_KEYS.forEach(clearItem(cont));\n            // @ts-ignore\n            cont.watcher = undefined;\n            Object.freeze(cont);\n        }\n    };\n};\n// fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param path to be watched\n * @param fullPath absolute path\n * @param options options to be passed to fs_watchFile\n * @param handlers container for event listener functions\n * @returns closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n    const { listener, rawEmitter } = handlers;\n    let cont = FsWatchFileInstances.get(fullPath);\n    // let listeners = new Set();\n    // let rawEmitters = new Set();\n    const copts = cont && cont.options;\n    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n        // \"Upgrade\" the watcher to persistence or a quicker interval.\n        // This creates some unlikely edge case issues if the user mixes\n        // settings in a very weird way, but solving for those cases\n        // doesn't seem worthwhile for the added complexity.\n        // listeners = cont.listeners;\n        // rawEmitters = cont.rawEmitters;\n        unwatchFile(fullPath);\n        cont = undefined;\n    }\n    if (cont) {\n        addAndConvert(cont, KEY_LISTENERS, listener);\n        addAndConvert(cont, KEY_RAW, rawEmitter);\n    }\n    else {\n        // TODO\n        // listeners.add(listener);\n        // rawEmitters.add(rawEmitter);\n        cont = {\n            listeners: listener,\n            rawEmitters: rawEmitter,\n            options,\n            watcher: watchFile(fullPath, options, (curr, prev) => {\n                foreach(cont.rawEmitters, (rawEmitter) => {\n                    rawEmitter(EV.CHANGE, fullPath, { curr, prev });\n                });\n                const currmtime = curr.mtimeMs;\n                if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n                    foreach(cont.listeners, (listener) => listener(path, curr));\n                }\n            }),\n        };\n        FsWatchFileInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n    // Removes this instance's listeners and closes the underlying fs_watchFile\n    // instance if there are no more listeners left.\n    return () => {\n        delFromSet(cont, KEY_LISTENERS, listener);\n        delFromSet(cont, KEY_RAW, rawEmitter);\n        if (isEmptySet(cont.listeners)) {\n            FsWatchFileInstances.delete(fullPath);\n            unwatchFile(fullPath);\n            cont.options = cont.watcher = undefined;\n            Object.freeze(cont);\n        }\n    };\n};\n/**\n * @mixin\n */\nexport class NodeFsHandler {\n    constructor(fsW) {\n        this.fsw = fsW;\n        this._boundHandleError = (error) => fsW._handleError(error);\n    }\n    /**\n     * Watch file for changes with fs_watchFile or fs_watch.\n     * @param path to file or dir\n     * @param listener on fs change\n     * @returns closer for the watcher instance\n     */\n    _watchWithNodeFs(path, listener) {\n        const opts = this.fsw.options;\n        const directory = sysPath.dirname(path);\n        const basename = sysPath.basename(path);\n        const parent = this.fsw._getWatchedDir(directory);\n        parent.add(basename);\n        const absolutePath = sysPath.resolve(path);\n        const options = {\n            persistent: opts.persistent,\n        };\n        if (!listener)\n            listener = EMPTY_FN;\n        let closer;\n        if (opts.usePolling) {\n            const enableBin = opts.interval !== opts.binaryInterval;\n            options.interval = enableBin && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n            closer = setFsWatchFileListener(path, absolutePath, options, {\n                listener,\n                rawEmitter: this.fsw._emitRaw,\n            });\n        }\n        else {\n            closer = setFsWatchListener(path, absolutePath, options, {\n                listener,\n                errHandler: this._boundHandleError,\n                rawEmitter: this.fsw._emitRaw,\n            });\n        }\n        return closer;\n    }\n    /**\n     * Watch a file and emit add event if warranted.\n     * @returns closer for the watcher instance\n     */\n    _handleFile(file, stats, initialAdd) {\n        if (this.fsw.closed) {\n            return;\n        }\n        const dirname = sysPath.dirname(file);\n        const basename = sysPath.basename(file);\n        const parent = this.fsw._getWatchedDir(dirname);\n        // stats is always present\n        let prevStats = stats;\n        // if the file is already being watched, do nothing\n        if (parent.has(basename))\n            return;\n        const listener = async (path, newStats) => {\n            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))\n                return;\n            if (!newStats || newStats.mtimeMs === 0) {\n                try {\n                    const newStats = await stat(file);\n                    if (this.fsw.closed)\n                        return;\n                    // Check that change event was not fired because of changed only accessTime.\n                    const at = newStats.atimeMs;\n                    const mt = newStats.mtimeMs;\n                    if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n                        this.fsw._emit(EV.CHANGE, file, newStats);\n                    }\n                    if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {\n                        this.fsw._closeFile(path);\n                        prevStats = newStats;\n                        const closer = this._watchWithNodeFs(file, listener);\n                        if (closer)\n                            this.fsw._addPathCloser(path, closer);\n                    }\n                    else {\n                        prevStats = newStats;\n                    }\n                }\n                catch (error) {\n                    // Fix issues where mtime is null but file is still present\n                    this.fsw._remove(dirname, basename);\n                }\n                // add is about to be emitted if file not already tracked in parent\n            }\n            else if (parent.has(basename)) {\n                // Check that change event was not fired because of changed only accessTime.\n                const at = newStats.atimeMs;\n                const mt = newStats.mtimeMs;\n                if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n                    this.fsw._emit(EV.CHANGE, file, newStats);\n                }\n                prevStats = newStats;\n            }\n        };\n        // kick off the watcher\n        const closer = this._watchWithNodeFs(file, listener);\n        // emit an add event if we're supposed to\n        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n            if (!this.fsw._throttle(EV.ADD, file, 0))\n                return;\n            this.fsw._emit(EV.ADD, file, stats);\n        }\n        return closer;\n    }\n    /**\n     * Handle symlinks encountered while reading a dir.\n     * @param entry returned by readdirp\n     * @param directory path of dir being read\n     * @param path of this item\n     * @param item basename of this item\n     * @returns true if no more processing is needed for this entry.\n     */\n    async _handleSymlink(entry, directory, path, item) {\n        if (this.fsw.closed) {\n            return;\n        }\n        const full = entry.fullPath;\n        const dir = this.fsw._getWatchedDir(directory);\n        if (!this.fsw.options.followSymlinks) {\n            // watch symlink directly (don't follow) and detect changes\n            this.fsw._incrReadyCount();\n            let linkPath;\n            try {\n                linkPath = await fsrealpath(path);\n            }\n            catch (e) {\n                this.fsw._emitReady();\n                return true;\n            }\n            if (this.fsw.closed)\n                return;\n            if (dir.has(item)) {\n                if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n                    this.fsw._symlinkPaths.set(full, linkPath);\n                    this.fsw._emit(EV.CHANGE, path, entry.stats);\n                }\n            }\n            else {\n                dir.add(item);\n                this.fsw._symlinkPaths.set(full, linkPath);\n                this.fsw._emit(EV.ADD, path, entry.stats);\n            }\n            this.fsw._emitReady();\n            return true;\n        }\n        // don't follow the same symlink more than once\n        if (this.fsw._symlinkPaths.has(full)) {\n            return true;\n        }\n        this.fsw._symlinkPaths.set(full, true);\n    }\n    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n        // Normalize the directory name on Windows\n        directory = sysPath.join(directory, '');\n        throttler = this.fsw._throttle('readdir', directory, 1000);\n        if (!throttler)\n            return;\n        const previous = this.fsw._getWatchedDir(wh.path);\n        const current = new Set();\n        let stream = this.fsw._readdirp(directory, {\n            fileFilter: (entry) => wh.filterPath(entry),\n            directoryFilter: (entry) => wh.filterDir(entry),\n        });\n        if (!stream)\n            return;\n        stream\n            .on(STR_DATA, async (entry) => {\n            if (this.fsw.closed) {\n                stream = undefined;\n                return;\n            }\n            const item = entry.path;\n            let path = sysPath.join(directory, item);\n            current.add(item);\n            if (entry.stats.isSymbolicLink() &&\n                (await this._handleSymlink(entry, directory, path, item))) {\n                return;\n            }\n            if (this.fsw.closed) {\n                stream = undefined;\n                return;\n            }\n            // Files that present in current directory snapshot\n            // but absent in previous are added to watch list and\n            // emit `add` event.\n            if (item === target || (!target && !previous.has(item))) {\n                this.fsw._incrReadyCount();\n                // ensure relativeness of path is preserved in case of watcher reuse\n                path = sysPath.join(dir, sysPath.relative(dir, path));\n                this._addToNodeFs(path, initialAdd, wh, depth + 1);\n            }\n        })\n            .on(EV.ERROR, this._boundHandleError);\n        return new Promise((resolve, reject) => {\n            if (!stream)\n                return reject();\n            stream.once(STR_END, () => {\n                if (this.fsw.closed) {\n                    stream = undefined;\n                    return;\n                }\n                const wasThrottled = throttler ? throttler.clear() : false;\n                resolve(undefined);\n                // Files that absent in current directory snapshot\n                // but present in previous emit `remove` event\n                // and are removed from @watched[directory].\n                previous\n                    .getChildren()\n                    .filter((item) => {\n                    return item !== directory && !current.has(item);\n                })\n                    .forEach((item) => {\n                    this.fsw._remove(directory, item);\n                });\n                stream = undefined;\n                // one more time for any missed in case changes came in extremely quickly\n                if (wasThrottled)\n                    this._handleRead(directory, false, wh, target, dir, depth, throttler);\n            });\n        });\n    }\n    /**\n     * Read directory to add / remove files from `@watched` list and re-read it on change.\n     * @param dir fs path\n     * @param stats\n     * @param initialAdd\n     * @param depth relative to user-supplied path\n     * @param target child path targeted for watch\n     * @param wh Common watch helpers for this path\n     * @param realpath\n     * @returns closer for the watcher instance.\n     */\n    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n        const tracked = parentDir.has(sysPath.basename(dir));\n        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n            this.fsw._emit(EV.ADD_DIR, dir, stats);\n        }\n        // ensure dir is tracked (harmless if redundant)\n        parentDir.add(sysPath.basename(dir));\n        this.fsw._getWatchedDir(dir);\n        let throttler;\n        let closer;\n        const oDepth = this.fsw.options.depth;\n        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n            if (!target) {\n                await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n                if (this.fsw.closed)\n                    return;\n            }\n            closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n                // if current directory is removed, do nothing\n                if (stats && stats.mtimeMs === 0)\n                    return;\n                this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n            });\n        }\n        return closer;\n    }\n    /**\n     * Handle added file, directory, or glob pattern.\n     * Delegates call to _handleFile / _handleDir after checks.\n     * @param path to file or ir\n     * @param initialAdd was the file added at watch instantiation?\n     * @param priorWh depth relative to user-supplied path\n     * @param depth Child path actually targeted for watch\n     * @param target Child path actually targeted for watch\n     */\n    async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n        const ready = this.fsw._emitReady;\n        if (this.fsw._isIgnored(path) || this.fsw.closed) {\n            ready();\n            return false;\n        }\n        const wh = this.fsw._getWatchHelpers(path);\n        if (priorWh) {\n            wh.filterPath = (entry) => priorWh.filterPath(entry);\n            wh.filterDir = (entry) => priorWh.filterDir(entry);\n        }\n        // evaluate what is at the path we're being asked to watch\n        try {\n            const stats = await statMethods[wh.statMethod](wh.watchPath);\n            if (this.fsw.closed)\n                return;\n            if (this.fsw._isIgnored(wh.watchPath, stats)) {\n                ready();\n                return false;\n            }\n            const follow = this.fsw.options.followSymlinks;\n            let closer;\n            if (stats.isDirectory()) {\n                const absPath = sysPath.resolve(path);\n                const targetPath = follow ? await fsrealpath(path) : path;\n                if (this.fsw.closed)\n                    return;\n                closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n                if (this.fsw.closed)\n                    return;\n                // preserve this symlink's target path\n                if (absPath !== targetPath && targetPath !== undefined) {\n                    this.fsw._symlinkPaths.set(absPath, targetPath);\n                }\n            }\n            else if (stats.isSymbolicLink()) {\n                const targetPath = follow ? await fsrealpath(path) : path;\n                if (this.fsw.closed)\n                    return;\n                const parent = sysPath.dirname(wh.watchPath);\n                this.fsw._getWatchedDir(parent).add(wh.watchPath);\n                this.fsw._emit(EV.ADD, wh.watchPath, stats);\n                closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n                if (this.fsw.closed)\n                    return;\n                // preserve this symlink's target path\n                if (targetPath !== undefined) {\n                    this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n                }\n            }\n            else {\n                closer = this._handleFile(wh.watchPath, stats, initialAdd);\n            }\n            ready();\n            if (closer)\n                this.fsw._addPathCloser(path, closer);\n            return false;\n        }\n        catch (error) {\n            if (this.fsw._handleError(error)) {\n                ready();\n                return path;\n            }\n        }\n    }\n}\n","/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */\nimport { stat as statcb } from 'fs';\nimport { stat, readdir } from 'fs/promises';\nimport { EventEmitter } from 'events';\nimport * as sysPath from 'path';\nimport { readdirp } from 'readdirp';\nimport { NodeFsHandler, EVENTS as EV, isWindows, isIBMi, EMPTY_FN, STR_CLOSE, STR_END, } from './handler.js';\nconst SLASH = '/';\nconst SLASH_SLASH = '//';\nconst ONE_DOT = '.';\nconst TWO_DOTS = '..';\nconst STRING_TYPE = 'string';\nconst BACK_SLASH_RE = /\\\\/g;\nconst DOUBLE_SLASH_RE = /\\/\\//;\nconst DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nconst REPLACER_RE = /^\\.[/\\\\]/;\nfunction arrify(item) {\n    return Array.isArray(item) ? item : [item];\n}\nconst isMatcherObject = (matcher) => typeof matcher === 'object' && matcher !== null && !(matcher instanceof RegExp);\nfunction createPattern(matcher) {\n    if (typeof matcher === 'function')\n        return matcher;\n    if (typeof matcher === 'string')\n        return (string) => matcher === string;\n    if (matcher instanceof RegExp)\n        return (string) => matcher.test(string);\n    if (typeof matcher === 'object' && matcher !== null) {\n        return (string) => {\n            if (matcher.path === string)\n                return true;\n            if (matcher.recursive) {\n                const relative = sysPath.relative(matcher.path, string);\n                if (!relative) {\n                    return false;\n                }\n                return !relative.startsWith('..') && !sysPath.isAbsolute(relative);\n            }\n            return false;\n        };\n    }\n    return () => false;\n}\nfunction normalizePath(path) {\n    if (typeof path !== 'string')\n        throw new Error('string expected');\n    path = sysPath.normalize(path);\n    path = path.replace(/\\\\/g, '/');\n    let prepend = false;\n    if (path.startsWith('//'))\n        prepend = true;\n    const DOUBLE_SLASH_RE = /\\/\\//;\n    while (path.match(DOUBLE_SLASH_RE))\n        path = path.replace(DOUBLE_SLASH_RE, '/');\n    if (prepend)\n        path = '/' + path;\n    return path;\n}\nfunction matchPatterns(patterns, testString, stats) {\n    const path = normalizePath(testString);\n    for (let index = 0; index < patterns.length; index++) {\n        const pattern = patterns[index];\n        if (pattern(path, stats)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction anymatch(matchers, testString) {\n    if (matchers == null) {\n        throw new TypeError('anymatch: specify first argument');\n    }\n    // Early cache for matchers.\n    const matchersArray = arrify(matchers);\n    const patterns = matchersArray.map((matcher) => createPattern(matcher));\n    if (testString == null) {\n        return (testString, stats) => {\n            return matchPatterns(patterns, testString, stats);\n        };\n    }\n    return matchPatterns(patterns, testString);\n}\nconst unifyPaths = (paths_) => {\n    const paths = arrify(paths_).flat();\n    if (!paths.every((p) => typeof p === STRING_TYPE)) {\n        throw new TypeError(`Non-string provided as watch path: ${paths}`);\n    }\n    return paths.map(normalizePathToUnix);\n};\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n    let str = string.replace(BACK_SLASH_RE, SLASH);\n    let prepend = false;\n    if (str.startsWith(SLASH_SLASH)) {\n        prepend = true;\n    }\n    while (str.match(DOUBLE_SLASH_RE)) {\n        str = str.replace(DOUBLE_SLASH_RE, SLASH);\n    }\n    if (prepend) {\n        str = SLASH + str;\n    }\n    return str;\n};\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n// TODO: refactor\nconst normalizeIgnored = (cwd = '') => (path) => {\n    if (typeof path === 'string') {\n        return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n    }\n    else {\n        return path;\n    }\n};\nconst getAbsolutePath = (path, cwd) => {\n    if (sysPath.isAbsolute(path)) {\n        return path;\n    }\n    return sysPath.join(cwd, path);\n};\nconst EMPTY_SET = Object.freeze(new Set());\n/**\n * Directory entry.\n */\nclass DirEntry {\n    constructor(dir, removeWatcher) {\n        this.path = dir;\n        this._removeWatcher = removeWatcher;\n        this.items = new Set();\n    }\n    add(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        if (item !== ONE_DOT && item !== TWO_DOTS)\n            items.add(item);\n    }\n    async remove(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        items.delete(item);\n        if (items.size > 0)\n            return;\n        const dir = this.path;\n        try {\n            await readdir(dir);\n        }\n        catch (err) {\n            if (this._removeWatcher) {\n                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n            }\n        }\n    }\n    has(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        return items.has(item);\n    }\n    getChildren() {\n        const { items } = this;\n        if (!items)\n            return [];\n        return [...items.values()];\n    }\n    dispose() {\n        this.items.clear();\n        this.path = '';\n        this._removeWatcher = EMPTY_FN;\n        this.items = EMPTY_SET;\n        Object.freeze(this);\n    }\n}\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nexport class WatchHelper {\n    constructor(path, follow, fsw) {\n        this.fsw = fsw;\n        const watchPath = path;\n        this.path = path = path.replace(REPLACER_RE, '');\n        this.watchPath = watchPath;\n        this.fullWatchPath = sysPath.resolve(watchPath);\n        this.dirParts = [];\n        this.dirParts.forEach((parts) => {\n            if (parts.length > 1)\n                parts.pop();\n        });\n        this.followSymlinks = follow;\n        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n    }\n    entryPath(entry) {\n        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));\n    }\n    filterPath(entry) {\n        const { stats } = entry;\n        if (stats && stats.isSymbolicLink())\n            return this.filterDir(entry);\n        const resolvedPath = this.entryPath(entry);\n        // TODO: what if stats is undefined? remove !\n        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n    filterDir(entry) {\n        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nexport class FSWatcher extends EventEmitter {\n    // Not indenting methods for history sake; for now.\n    constructor(_opts = {}) {\n        super();\n        this.closed = false;\n        this._closers = new Map();\n        this._ignoredPaths = new Set();\n        this._throttled = new Map();\n        this._streams = new Set();\n        this._symlinkPaths = new Map();\n        this._watched = new Map();\n        this._pendingWrites = new Map();\n        this._pendingUnlinks = new Map();\n        this._readyCount = 0;\n        this._readyEmitted = false;\n        const awf = _opts.awaitWriteFinish;\n        const DEF_AWF = { stabilityThreshold: 2000, pollInterval: 100 };\n        const opts = {\n            // Defaults\n            persistent: true,\n            ignoreInitial: false,\n            ignorePermissionErrors: false,\n            interval: 100,\n            binaryInterval: 300,\n            followSymlinks: true,\n            usePolling: false,\n            // useAsync: false,\n            atomic: true, // NOTE: overwritten later (depends on usePolling)\n            ..._opts,\n            // Change format\n            ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),\n            awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === 'object' ? { ...DEF_AWF, ...awf } : false,\n        };\n        // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n        if (isIBMi)\n            opts.usePolling = true;\n        // Editor atomic write normalization enabled by default with fs.watch\n        if (opts.atomic === undefined)\n            opts.atomic = !opts.usePolling;\n        // opts.atomic = typeof _opts.atomic === 'number' ? _opts.atomic : 100;\n        // Global override. Useful for developers, who need to force polling for all\n        // instances of chokidar, regardless of usage / dependency depth\n        const envPoll = process.env.CHOKIDAR_USEPOLLING;\n        if (envPoll !== undefined) {\n            const envLower = envPoll.toLowerCase();\n            if (envLower === 'false' || envLower === '0')\n                opts.usePolling = false;\n            else if (envLower === 'true' || envLower === '1')\n                opts.usePolling = true;\n            else\n                opts.usePolling = !!envLower;\n        }\n        const envInterval = process.env.CHOKIDAR_INTERVAL;\n        if (envInterval)\n            opts.interval = Number.parseInt(envInterval, 10);\n        // This is done to emit ready only once, but each 'add' will increase that?\n        let readyCalls = 0;\n        this._emitReady = () => {\n            readyCalls++;\n            if (readyCalls >= this._readyCount) {\n                this._emitReady = EMPTY_FN;\n                this._readyEmitted = true;\n                // use process.nextTick to allow time for listener to be bound\n                process.nextTick(() => this.emit(EV.READY));\n            }\n        };\n        this._emitRaw = (...args) => this.emit(EV.RAW, ...args);\n        this._boundRemove = this._remove.bind(this);\n        this.options = opts;\n        this._nodeFsHandler = new NodeFsHandler(this);\n        // You’re frozen when your heart’s not open.\n        Object.freeze(opts);\n    }\n    _addIgnoredPath(matcher) {\n        if (isMatcherObject(matcher)) {\n            // return early if we already have a deeply equal matcher object\n            for (const ignored of this._ignoredPaths) {\n                if (isMatcherObject(ignored) &&\n                    ignored.path === matcher.path &&\n                    ignored.recursive === matcher.recursive) {\n                    return;\n                }\n            }\n        }\n        this._ignoredPaths.add(matcher);\n    }\n    _removeIgnoredPath(matcher) {\n        this._ignoredPaths.delete(matcher);\n        // now find any matcher objects with the matcher as path\n        if (typeof matcher === 'string') {\n            for (const ignored of this._ignoredPaths) {\n                // TODO (43081j): make this more efficient.\n                // probably just make a `this._ignoredDirectories` or some\n                // such thing.\n                if (isMatcherObject(ignored) && ignored.path === matcher) {\n                    this._ignoredPaths.delete(ignored);\n                }\n            }\n        }\n    }\n    // Public methods\n    /**\n     * Adds paths to be watched on an existing FSWatcher instance.\n     * @param paths_ file or file list. Other arguments are unused\n     */\n    add(paths_, _origAdd, _internal) {\n        const { cwd } = this.options;\n        this.closed = false;\n        this._closePromise = undefined;\n        let paths = unifyPaths(paths_);\n        if (cwd) {\n            paths = paths.map((path) => {\n                const absPath = getAbsolutePath(path, cwd);\n                // Check `path` instead of `absPath` because the cwd portion can't be a glob\n                return absPath;\n            });\n        }\n        paths.forEach((path) => {\n            this._removeIgnoredPath(path);\n        });\n        this._userIgnored = undefined;\n        if (!this._readyCount)\n            this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map(async (path) => {\n            const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, undefined, 0, _origAdd);\n            if (res)\n                this._emitReady();\n            return res;\n        })).then((results) => {\n            if (this.closed)\n                return;\n            results.forEach((item) => {\n                if (item)\n                    this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n            });\n        });\n        return this;\n    }\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     */\n    unwatch(paths_) {\n        if (this.closed)\n            return this;\n        const paths = unifyPaths(paths_);\n        const { cwd } = this.options;\n        paths.forEach((path) => {\n            // convert to absolute path unless relative path already matches\n            if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n                if (cwd)\n                    path = sysPath.join(cwd, path);\n                path = sysPath.resolve(path);\n            }\n            this._closePath(path);\n            this._addIgnoredPath(path);\n            if (this._watched.has(path)) {\n                this._addIgnoredPath({\n                    path,\n                    recursive: true,\n                });\n            }\n            // reset the cached userIgnored anymatch fn\n            // to make ignoredPaths changes effective\n            this._userIgnored = undefined;\n        });\n        return this;\n    }\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     */\n    close() {\n        if (this._closePromise) {\n            return this._closePromise;\n        }\n        this.closed = true;\n        // Memory management.\n        this.removeAllListeners();\n        const closers = [];\n        this._closers.forEach((closerList) => closerList.forEach((closer) => {\n            const promise = closer();\n            if (promise instanceof Promise)\n                closers.push(promise);\n        }));\n        this._streams.forEach((stream) => stream.destroy());\n        this._userIgnored = undefined;\n        this._readyCount = 0;\n        this._readyEmitted = false;\n        this._watched.forEach((dirent) => dirent.dispose());\n        this._closers.clear();\n        this._watched.clear();\n        this._streams.clear();\n        this._symlinkPaths.clear();\n        this._throttled.clear();\n        this._closePromise = closers.length\n            ? Promise.all(closers).then(() => undefined)\n            : Promise.resolve();\n        return this._closePromise;\n    }\n    /**\n     * Expose list of watched paths\n     * @returns for chaining\n     */\n    getWatched() {\n        const watchList = {};\n        this._watched.forEach((entry, dir) => {\n            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n            const index = key || ONE_DOT;\n            watchList[index] = entry.getChildren().sort();\n        });\n        return watchList;\n    }\n    emitWithAll(event, args) {\n        this.emit(event, ...args);\n        if (event !== EV.ERROR)\n            this.emit(EV.ALL, event, ...args);\n    }\n    // Common helpers\n    // --------------\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param event Type of event\n     * @param path File or directory path\n     * @param stats arguments to be passed with event\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    async _emit(event, path, stats) {\n        if (this.closed)\n            return;\n        const opts = this.options;\n        if (isWindows)\n            path = sysPath.normalize(path);\n        if (opts.cwd)\n            path = sysPath.relative(opts.cwd, path);\n        const args = [path];\n        if (stats != null)\n            args.push(stats);\n        const awf = opts.awaitWriteFinish;\n        let pw;\n        if (awf && (pw = this._pendingWrites.get(path))) {\n            pw.lastChange = new Date();\n            return this;\n        }\n        if (opts.atomic) {\n            if (event === EV.UNLINK) {\n                this._pendingUnlinks.set(path, [event, ...args]);\n                setTimeout(() => {\n                    this._pendingUnlinks.forEach((entry, path) => {\n                        this.emit(...entry);\n                        this.emit(EV.ALL, ...entry);\n                        this._pendingUnlinks.delete(path);\n                    });\n                }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n                return this;\n            }\n            if (event === EV.ADD && this._pendingUnlinks.has(path)) {\n                event = EV.CHANGE;\n                this._pendingUnlinks.delete(path);\n            }\n        }\n        if (awf && (event === EV.ADD || event === EV.CHANGE) && this._readyEmitted) {\n            const awfEmit = (err, stats) => {\n                if (err) {\n                    event = EV.ERROR;\n                    args[0] = err;\n                    this.emitWithAll(event, args);\n                }\n                else if (stats) {\n                    // if stats doesn't exist the file must have been deleted\n                    if (args.length > 1) {\n                        args[1] = stats;\n                    }\n                    else {\n                        args.push(stats);\n                    }\n                    this.emitWithAll(event, args);\n                }\n            };\n            this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n            return this;\n        }\n        if (event === EV.CHANGE) {\n            const isThrottled = !this._throttle(EV.CHANGE, path, 50);\n            if (isThrottled)\n                return this;\n        }\n        if (opts.alwaysStat &&\n            stats === undefined &&\n            (event === EV.ADD || event === EV.ADD_DIR || event === EV.CHANGE)) {\n            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n            let stats;\n            try {\n                stats = await stat(fullPath);\n            }\n            catch (err) {\n                // do nothing\n            }\n            // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n            if (!stats || this.closed)\n                return;\n            args.push(stats);\n        }\n        this.emitWithAll(event, args);\n        return this;\n    }\n    /**\n     * Common handler for errors\n     * @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    _handleError(error) {\n        const code = error && error.code;\n        if (error &&\n            code !== 'ENOENT' &&\n            code !== 'ENOTDIR' &&\n            (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))) {\n            this.emit(EV.ERROR, error);\n        }\n        return error || this.closed;\n    }\n    /**\n     * Helper utility for throttling\n     * @param actionType type being throttled\n     * @param path being acted upon\n     * @param timeout duration of time to suppress duplicate actions\n     * @returns tracking object or false if action should be suppressed\n     */\n    _throttle(actionType, path, timeout) {\n        if (!this._throttled.has(actionType)) {\n            this._throttled.set(actionType, new Map());\n        }\n        const action = this._throttled.get(actionType);\n        if (!action)\n            throw new Error('invalid throttle');\n        const actionPath = action.get(path);\n        if (actionPath) {\n            actionPath.count++;\n            return false;\n        }\n        // eslint-disable-next-line prefer-const\n        let timeoutObject;\n        const clear = () => {\n            const item = action.get(path);\n            const count = item ? item.count : 0;\n            action.delete(path);\n            clearTimeout(timeoutObject);\n            if (item)\n                clearTimeout(item.timeoutObject);\n            return count;\n        };\n        timeoutObject = setTimeout(clear, timeout);\n        const thr = { timeoutObject, clear, count: 0 };\n        action.set(path, thr);\n        return thr;\n    }\n    _incrReadyCount() {\n        return this._readyCount++;\n    }\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param path being acted upon\n     * @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param event\n     * @param awfEmit Callback to be called when ready for event to be emitted.\n     */\n    _awaitWriteFinish(path, threshold, event, awfEmit) {\n        const awf = this.options.awaitWriteFinish;\n        if (typeof awf !== 'object')\n            return;\n        const pollInterval = awf.pollInterval;\n        let timeoutHandler;\n        let fullPath = path;\n        if (this.options.cwd && !sysPath.isAbsolute(path)) {\n            fullPath = sysPath.join(this.options.cwd, path);\n        }\n        const now = new Date();\n        const writes = this._pendingWrites;\n        function awaitWriteFinishFn(prevStat) {\n            statcb(fullPath, (err, curStat) => {\n                if (err || !writes.has(path)) {\n                    if (err && err.code !== 'ENOENT')\n                        awfEmit(err);\n                    return;\n                }\n                const now = Number(new Date());\n                if (prevStat && curStat.size !== prevStat.size) {\n                    writes.get(path).lastChange = now;\n                }\n                const pw = writes.get(path);\n                const df = now - pw.lastChange;\n                if (df >= threshold) {\n                    writes.delete(path);\n                    awfEmit(undefined, curStat);\n                }\n                else {\n                    timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);\n                }\n            });\n        }\n        if (!writes.has(path)) {\n            writes.set(path, {\n                lastChange: now,\n                cancelWait: () => {\n                    writes.delete(path);\n                    clearTimeout(timeoutHandler);\n                    return event;\n                },\n            });\n            timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);\n        }\n    }\n    /**\n     * Determines whether user has asked to ignore this path.\n     */\n    _isIgnored(path, stats) {\n        if (this.options.atomic && DOT_RE.test(path))\n            return true;\n        if (!this._userIgnored) {\n            const { cwd } = this.options;\n            const ign = this.options.ignored;\n            const ignored = (ign || []).map(normalizeIgnored(cwd));\n            const ignoredPaths = [...this._ignoredPaths];\n            const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];\n            this._userIgnored = anymatch(list, undefined);\n        }\n        return this._userIgnored(path, stats);\n    }\n    _isntIgnored(path, stat) {\n        return !this._isIgnored(path, stat);\n    }\n    /**\n     * Provides a set of common helpers and properties relating to symlink handling.\n     * @param path file or directory pattern being watched\n     */\n    _getWatchHelpers(path) {\n        return new WatchHelper(path, this.options.followSymlinks, this);\n    }\n    // Directory helpers\n    // -----------------\n    /**\n     * Provides directory tracking objects\n     * @param directory path of the directory\n     */\n    _getWatchedDir(directory) {\n        const dir = sysPath.resolve(directory);\n        if (!this._watched.has(dir))\n            this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n        return this._watched.get(dir);\n    }\n    // File helpers\n    // ------------\n    /**\n     * Check for read permissions: https://stackoverflow.com/a/11781404/1358405\n     */\n    _hasReadPermissions(stats) {\n        if (this.options.ignorePermissionErrors)\n            return true;\n        return Boolean(Number(stats.mode) & 0o400);\n    }\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param directory within which the following item is located\n     * @param item      base path of item/directory\n     */\n    _remove(directory, item, isDirectory) {\n        // if what is being deleted is a directory, get that directory's paths\n        // for recursive deleting and cleaning of watched object\n        // if it is not a directory, nestedDirectoryChildren will be empty array\n        const path = sysPath.join(directory, item);\n        const fullPath = sysPath.resolve(path);\n        isDirectory =\n            isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n        // prevent duplicate handling in case of arriving here nearly simultaneously\n        // via multiple paths (such as _handleFile and _handleDir)\n        if (!this._throttle('remove', path, 100))\n            return;\n        // if the only watched file is removed, watch for its return\n        if (!isDirectory && this._watched.size === 1) {\n            this.add(directory, item, true);\n        }\n        // This will create a new entry in the watched object in either case\n        // so we got to do the directory check beforehand\n        const wp = this._getWatchedDir(path);\n        const nestedDirectoryChildren = wp.getChildren();\n        // Recursively remove children directories / files.\n        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));\n        // Check if item was on the watched list and remove it\n        const parent = this._getWatchedDir(directory);\n        const wasTracked = parent.has(item);\n        parent.remove(item);\n        // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n        // but never removed from the map in case the path was deleted.\n        // This leads to an incorrect state if the path was recreated:\n        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n        if (this._symlinkPaths.has(fullPath)) {\n            this._symlinkPaths.delete(fullPath);\n        }\n        // If we wait for this file to be fully written, cancel the wait.\n        let relPath = path;\n        if (this.options.cwd)\n            relPath = sysPath.relative(this.options.cwd, path);\n        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n            const event = this._pendingWrites.get(relPath).cancelWait();\n            if (event === EV.ADD)\n                return;\n        }\n        // The Entry will either be a directory that just got removed\n        // or a bogus entry to a file, in either case we have to remove it\n        this._watched.delete(path);\n        this._watched.delete(fullPath);\n        const eventName = isDirectory ? EV.UNLINK_DIR : EV.UNLINK;\n        if (wasTracked && !this._isIgnored(path))\n            this._emit(eventName, path);\n        // Avoid conflicts if we later create another file with the same name\n        this._closePath(path);\n    }\n    /**\n     * Closes all watchers for a path\n     */\n    _closePath(path) {\n        this._closeFile(path);\n        const dir = sysPath.dirname(path);\n        this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n    /**\n     * Closes only file-specific watchers\n     */\n    _closeFile(path) {\n        const closers = this._closers.get(path);\n        if (!closers)\n            return;\n        closers.forEach((closer) => closer());\n        this._closers.delete(path);\n    }\n    _addPathCloser(path, closer) {\n        if (!closer)\n            return;\n        let list = this._closers.get(path);\n        if (!list) {\n            list = [];\n            this._closers.set(path, list);\n        }\n        list.push(closer);\n    }\n    _readdirp(root, opts) {\n        if (this.closed)\n            return;\n        const options = { type: EV.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };\n        let stream = readdirp(root, options);\n        this._streams.add(stream);\n        stream.once(STR_CLOSE, () => {\n            stream = undefined;\n        });\n        stream.once(STR_END, () => {\n            if (stream) {\n                this._streams.delete(stream);\n                stream = undefined;\n            }\n        });\n        return stream;\n    }\n}\n/**\n * Instantiates watcher with paths to be tracked.\n * @param paths file / directory paths\n * @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others\n * @returns an instance of FSWatcher for chaining.\n * @example\n * const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });\n * watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })\n */\nexport function watch(paths, options = {}) {\n    const watcher = new FSWatcher(options);\n    watcher.add(paths);\n    return watcher;\n}\nexport default { watch, FSWatcher };\n","import { app, BrowserWindow, ipcMain, dialog } from 'electron';\r\nimport path from 'path';\r\nimport Store from 'electron-store';\r\nimport fsExtra from 'fs-extra';\r\nimport { fileURLToPath } from 'url';\r\nimport * as chokidar from 'chokidar';\r\nimport { readFile } from 'fs/promises';\r\n\r\n// ES Module __dirname equivalent\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\n// File watcher instance\r\nlet watcher: chokidar.FSWatcher | null = null;\r\n\r\n// Function to start watching a folder\r\nfunction startWatching(folderPath: string, hiddenList: string[]) {\r\n  // Stop any existing watcher\r\n  if (watcher) {\r\n    watcher.close();\r\n  }\r\n\r\n  // Initialize watcher with ignore patterns\r\n  watcher = chokidar.watch(folderPath, {\r\n    ignored: (watchPath: string) => hiddenList.some(hidden => watchPath.includes(hidden)),\r\n    persistent: true,\r\n    ignoreInitial: true\r\n  });\r\n\r\n  // File events\r\n  watcher\r\n    .on('add', (watchPath: string) => mainWindow?.webContents.send('file-created', watchPath))\r\n    .on('change', (watchPath: string) => mainWindow?.webContents.send('file-changed', watchPath))\r\n    .on('unlink', (watchPath: string) => mainWindow?.webContents.send('file-deleted', watchPath))\r\n    .on('addDir', (watchPath: string) => mainWindow?.webContents.send('dir-created', watchPath))\r\n    .on('unlinkDir', (watchPath: string) => mainWindow?.webContents.send('dir-deleted', watchPath))\r\n    .on('error', (error: unknown) => console.error('Watcher error:', error));\r\n}\r\n\r\n// Disable GPU acceleration to avoid cache issues\r\napp.disableHardwareAcceleration();\r\n// Disable GPU cache\r\napp.commandLine.appendSwitch('disable-gpu-cache');\r\n\r\n// Default configuration\r\nconst defaultConfig = {\r\n  lastFolderPath: '',\r\n  hiddenList: [\r\n    // Development folders and files\r\n    '.git', \r\n    '.vscode', \r\n    'dist-electron', \r\n    'node_modules', \r\n    'package-lock.json',\r\n    // ESLint files\r\n    '.eslintignore',\r\n    '.eslintrc',\r\n    '.eslintrc.json',\r\n    '.eslintrc.js',\r\n    // Image formats\r\n    '.jpg',\r\n    '.jpeg',\r\n    '.png',\r\n    '.gif',\r\n    '.svg',\r\n    '.ico',\r\n    '.webp',\r\n    '.bmp',\r\n    '.tiff',\r\n    '.idx'\r\n  ],\r\n  introRules: `Present a complete plan to solve the problem and implement it in the codebase.\r\n\r\nAt the end of your response, respond with the following XML section (if applicable).\r\n\r\nXML Section:\r\n\r\nDo not get lazy. Always output the full code in the XML section.\r\nEnclose this entire section in a markdown codeblock\r\nInclude all of the changed files\r\nSpecify each file operation with CREATE, UPDATE, or DELETE\r\nFor CREATE or UPDATE operations, include the full file code\r\nInclude the full file path (relative to the project directory, good: app/page.tsx, bad: /Users/mckaywrigley/Desktop/projects/new-chat-template/app/page.tsx)\r\nEnclose the code with ![CDATA[CODE HERE]]\r\nUse the following XML structure:\r\n<code_changes>\r\n  <changed_files>\r\n    <file>\r\n      <file_operation>__FILE OPERATION HERE__</file_operation>\r\n      <file_path>__FILE PATH HERE__</file_path>\r\n      <file_code><![CDATA[\r\n__FULL FILE CODE HERE__\r\n]]></file_code>\r\n    </file>\r\n    __REMAINING FILES HERE__\r\n  </changed_files>\r\n</code_changes>\r\nOther rules:\r\n\r\nDO NOT remove <ai_context> sections. These are to provide you additional context about each file.\r\nIf you create a file, add an <ai_context> comment section at the top of the file.\r\nIf you update a file make sure its <ai_context> stays up-to-date\r\nDO NOT add comments related to your edits\r\nDO NOT remove my existing comments\r\nWe may go back and forth a few times. If we do, remember to continue to output the entirety of the code in an XML section (if applicable).\r\n\r\nTake all the time you need.`,\r\n  selectedFiles: [] as string[],\r\n  userTask: '',\r\n};\r\n\r\n// Initialize store for local data\r\nconst store = new Store({\r\n  name: 'eazypaste-config',\r\n  defaults: defaultConfig,\r\n});\r\n\r\nlet mainWindow: BrowserWindow | null = null;\r\n\r\nasync function createWindow() {\r\n  mainWindow = new BrowserWindow({\r\n    width: 1600,\r\n    height: 1000,\r\n    minWidth: 1200,\r\n    minHeight: 800,\r\n    webPreferences: {\r\n      preload: path.join(__dirname, 'preload.js'),\r\n      nodeIntegration: false,\r\n      contextIsolation: true,\r\n    },\r\n  });\r\n\r\n  // Load your Vite dev server or the built index.html\r\n  if (import.meta.env.MODE === 'development') {\r\n    mainWindow.loadURL('http://localhost:5173');\r\n  } else {\r\n    mainWindow.loadFile(path.join(__dirname, '../dist/index.html'));\r\n  }\r\n}\r\n\r\napp.whenReady().then(async () => {\r\n  await createWindow();\r\n\r\n  app.on('activate', function () {\r\n    if (BrowserWindow.getAllWindows().length === 0) createWindow();\r\n  });\r\n});\r\n\r\n// Graceful shutdown\r\napp.on('window-all-closed', function () {\r\n  if (process.platform !== 'darwin') app.quit();\r\n});\r\n\r\n/* IPC Handlers */\r\n\r\n// 1) Open folder dialog\r\nipcMain.handle('select-folder', async () => {\r\n  const result = await dialog.showOpenDialog({\r\n    properties: ['openDirectory'],\r\n  });\r\n\r\n  if (!result.canceled && result.filePaths && result.filePaths.length > 0) {\r\n    store.set('lastFolderPath', result.filePaths[0]);\r\n    return result.filePaths[0];\r\n  }\r\n  return null;\r\n});\r\n\r\n// 2) Get stored data\r\nipcMain.handle('get-store-data', async () => {\r\n  return {\r\n    lastFolderPath: store.get('lastFolderPath'),\r\n    hiddenList: store.get('hiddenList'),\r\n    introRules: store.get('introRules'),\r\n    selectedFiles: store.get('selectedFiles'),\r\n    userTask: store.get('userTask'),\r\n  };\r\n});\r\n\r\n// 3) Set store data\r\nipcMain.handle('set-store-data', async (_, data: any) => {\r\n  // data should be an object containing keys that exist in the store\r\n  Object.entries(data).forEach(([key, value]) => {\r\n    store.set(key, value);\r\n  });\r\n});\r\n\r\n// 4) Get folder tree structure (excluding hidden items)\r\nipcMain.handle('get-folder-tree', async (_, folderPath: string, hiddenList: string[]) => {\r\n  if (!folderPath) return [];\r\n\r\n  const getFilesRecursively = async (dir: string): Promise<any[]> => {\r\n    const items = await fsExtra.readdir(dir, { withFileTypes: true });\r\n    const result = [];\r\n\r\n    for (const item of items) {\r\n      // Skip hidden items\r\n      if (hiddenList.some(hidden => item.name.includes(hidden))) continue;\r\n\r\n      const itemPath = path.join(dir, item.name);\r\n      if (item.isDirectory()) {\r\n        // For directories, recursively get contents\r\n        const children = await getFilesRecursively(itemPath);\r\n        // Only add directory if it has visible children or is empty\r\n        result.push({\r\n          n: item.name,\r\n          p: itemPath,\r\n          d: true,\r\n          c: children // Add children directly to the directory node\r\n        });\r\n      } else {\r\n        result.push({\r\n          n: item.name,\r\n          p: itemPath,\r\n          d: false\r\n        });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  try {\r\n    return await getFilesRecursively(folderPath);\r\n  } catch (error) {\r\n    console.error('Error reading folder structure:', error);\r\n    return [];\r\n  }\r\n});\r\n\r\n// 5) Get folder contents (for dynamic loading)\r\nipcMain.handle('get-folder-contents', async (_, folderPath: string, hiddenList: string[]) => {\r\n  if (!folderPath) return [];\r\n\r\n  try {\r\n    const items = await fsExtra.readdir(folderPath, { withFileTypes: true });\r\n    const contents = [];\r\n\r\n    for (const item of items) {\r\n      // Skip hidden items\r\n      if (hiddenList.some(hidden => item.name.includes(hidden))) continue;\r\n\r\n      const itemPath = path.join(folderPath, item.name);\r\n      // Ensure we only send serializable data\r\n      contents.push({\r\n        name: String(item.name),\r\n        path: String(itemPath),\r\n        isDirectory: Boolean(item.isDirectory()),\r\n        type: item.isDirectory() ? 'directory' : 'file'\r\n      });\r\n    }\r\n\r\n    // Log the data being sent\r\n    console.log('Sending folder contents:', JSON.stringify(contents));\r\n    return contents;\r\n  } catch (error) {\r\n    console.error('Error reading folder contents:', error);\r\n    return [];\r\n  }\r\n});\r\n\r\n// 6) Read file content\r\nipcMain.handle('read-file', async (_, filePath: string) => {\r\n  try {\r\n    const content = await fsExtra.readFile(filePath, 'utf-8');\r\n    return content;\r\n  } catch (error) {\r\n    console.error('Error reading file', filePath, error);\r\n    return '';\r\n  }\r\n});\r\n\r\n// Add path operations handler\r\nipcMain.handle('get-relative-path', async (_, filePath: string, rootPath: string) => {\r\n  return path.relative(rootPath, filePath);\r\n});\r\n\r\nipcMain.handle('get-basename', async (_, filePath: string) => {\r\n  return path.basename(filePath);\r\n});\r\n\r\n// Add reset handler\r\nipcMain.handle('reset-to-defaults', async () => {\r\n  try {\r\n    // Reset each value to its default\r\n    Object.entries(defaultConfig).forEach(([key, value]) => {\r\n      store.set(key, value);\r\n    });\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error resetting to defaults:', error);\r\n    return false;\r\n  }\r\n});\r\n\r\n// IPC handler for starting file watching\r\nipcMain.handle('start-watching', async (_, folderPath: string) => {\r\n  const hiddenList = store.get('hiddenList') as string[];\r\n  startWatching(folderPath, hiddenList);\r\n  return true;\r\n});\r\n\r\n// IPC handler for stopping file watching\r\nipcMain.handle('stop-watching', async () => {\r\n  if (watcher) {\r\n    await watcher.close();\r\n    watcher = null;\r\n  }\r\n  return true;\r\n});\r\n\r\n// Add this IPC handler with the other handlers\r\nipcMain.handle('get-file-contents', async (_event, filePath: string) => {\r\n  try {\r\n    const content = await readFile(filePath, 'utf-8');\r\n    return content;\r\n  } catch (error) {\r\n    console.error('Error reading file:', error);\r\n    throw error;\r\n  }\r\n});\r\n"],"names":["type","presolve","pjoin","prelative","psep","osType","lstat","stat","fs_watch","watcher","rawEmitter","listener","newStats","closer","fsrealpath","resolve","realpath","stats","relative","DOUBLE_SLASH_RE","testString","readdir","EV","path","statcb","now","chokidar.watch"],"mappings":"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","x_google_ignoreList":[0,1,2]}